---
date: 2025-12-08
layout: post
title: 자바 프로젝트 HR-BANK 
categories: [자바 프로젝트]
tags: [JAVA]

---
### 황준영 개인 개발 리포트

## 1. 프로젝트 개요

- 프로젝트 목적: HR-BANK 인적 관리 시스템 서버 , DataBase 개발 및 배포
- 핵심 기능:
  - 부서 정보 관리
  - 직원 정보 관리
  - 직원 정보 수정 이력 관리
  - 전체 직원 정보 데이터 백업
  - 주요 인사 통계 보여주는 대시보드

- 프로젝트 기간: 2025.11.27 - 2025.12.08
- 기술 스택: JAVA ,Spring Boot, JPA, Gradle , PostgreSQL,

---

## 2. 담당한 작업

- 역할: 파일 정보 관리 , 파일 데이터 로컬 디스크 저장, 데이터 백업 관리
- 주요 기여 내용:
  - 시연 영상 제작
  - 파일 메타 정보 관리
  - 파일 데이터 로컬 디스크 저장
  - 데이터 백업 관리
  - 데이터 백업 배치 시스템
  - 배포 서버 테스트
- 구현한 기능 목록:
  - File 엔티티 서비스 , 컨트롤러, 레포지토리 레이어 구현
  - 로컬 디스크 에 파일 저장 로직 구현  (FileStorage)
  - 데이터 백업 서비스, 컨트롤러, 레포지토리 레이어 구현
  - 데이터 백업 주기적으로 진행하는 배치 시스템 구현

---

## 3. 기술적 성과

- 사용한 기술 및 도입 이유:


    - **OpenCSV**
        - CSV 파일을 `BufferedWriter`로 직접 작성할 경우, 헤더 처리나 문자열 포맷팅에서 오류가 발생할 가능성이 있었다. 이를 해결하고 안정적으로 CSV를 생성하기 위해 Java에서 널리 사용되는 OpenCSV 라이브러리를 도입하였다.
    - **JPA**
        - JPA의 영속성 컨텍스트를 활용해 데이터베이스 데이터를 서버 비즈니스 로직에서 일관성 있게 관리할 수 있도록 하기 위해 사용하였다. 또한 복잡한 SQL 대신 JPQL을 활용해 다양한 조건의 데이터를 보다 효율적으로 조회하고자 JPA를 적용하였다.

- 개발 과정에서 만든 핵심 기능 설명:
  - **대용량 직원 조회 시 OOM 방지 기능 구현**

    전체 직원 정보를 한 번에 로딩하지 않도록 Page 단위로 순차 조회하는 방식을 도입하여 메모리 사용을 안정적으로 관리하였다.

  - **백업 데이터 조회를 위한 Native Query 기반 필터링 기능 개발**

    다양한 필터 조건(작업자, 상태, 기간 등)에 따라 정확한 백업 데이터를 조회할 수 있도록 Native Query로 효율적인 DB 조회 로직을 구현하였다.

  - **파일 유형별 로컬 디스크 저장 구조 설계 및 구현**

    파일 종류(프로필, 백업, 로그)에 따라 `storage/profile`, `storage/backup`, `storage/log`처럼 디렉토리를 구분해 저장하며, 파일 데이터를 바이트 단위로 안정적으로 기록하는 기능을 구현하였다.

  - **프로필 파일 저장 및 다운로드 처리 로직 구현**

    로컬 디스크에는 파일을 내부 ID로 저장하고, 다운로드 시에는 사용자가 업로드한 원래 파일명으로 받을 수 있도록 파일명 매핑 로직을 설계하였다.

  - **백업 생성 과정에서의 예외 처리 및 에러 로그 자동 기록 기능 개발**

    OOM, 잘못된 파일 형식 등 백업 생성 중 발생하는 다양한 예외 상황을 감지하여 로컬 저장소에 에러 로그 파일로 기록하고 저장하는 안정성 보강 로직을 구현하였다.


---

# 🟦 Situation ( 백업 트러블 슈팅)

- API 명세서에서는 “파일을 로컬 디스크에 저장하는 동안 Backup 상태를 ‘진행중’으로 표시하고, 저장
- 완료 후 ‘완료됨’으로 변경하라”고 요구했다.
- 하지만 Backup 생성 로직은 하나의 트랜잭션 메서드 내부에서 처리되고 있었기 때문에, 트랜잭션이 완료되기 전까지는 중간 상태(진행중 → 완료됨)를 DB에 반영할 수 없는 구조였다.
- 이로 인해 요구사항을 그대로 구현하는 것은 기술적으로 불가능한 상황이었다.

### 🟧 Task

- 트랜잭션 구조에서 발생하는 제약을 분석하고, 요구사항을 충족할 수 있는지 판단해야 했다.
- 만약 요구사항이 비현실적이라면, 팀과 협의하여 서비스 흐름에 맞는 대안을 제시해야 했다.

### 🟩 Action

- 트랜잭션 동작 방식과 상태 변경의 반영 시점을 다시 학습하여 문제의 근본 원인을 명확히 파악했다.
- 프론트 요청을 두 번 보내거나 지연 시간을 두어 상태를 나눠 전달하는 방식도 검토했지만, 현재 서비스 구조와 맞지 않는다는 결론을 내렸다.
- 이 이슈를 팀원들, 주강사님, 그리고 동일한 기능을 담당한 다른 팀과 충분히 논의하며 여러 대안을 비교·검토했다.
- 최종적으로 요구사항 자체가 현재 기술 구조와 맞지 않는다 판단하고, 이를 팀과 공유한 뒤 서비스 흐름에 가장 적합한 방식으로 Backup 상태 로직을 재설계했다.

### 🟨 Result

- 기술적 제약과 서비스 흐름을 모두 고려한 현실적인 구현 방식으로 로직을 구성하여 PR 승인을 받았다.
- 명세서 요구를 그대로 따르기보다, 팀과의 소통을 통해 서비스에 맞는 방향으로 조정하는 것이 중요하다는 점을 실무적으로 경험할 수 있었다.

### 🟦 Situation (파일 트러블 슈팅)

- 백업 파일을 로컬 디스크에 저장하는 과정에서 직원 수가 증가할수록 저장 속도가 급격히 느려지는 문제가 발생했다.
- 분석 결과, 전체 Employee 객체를 하나씩 디스크에 write하는 구조였고, 매번 OS write 호출이 발생하며 디스크 I/O 병목이 생기고 있었다.

### 🟧 Task

- 백업 파일 생성 속도를 개선하고, 대량 데이터 처리 시에도 안정적으로 작동할 수 있는 저장 방식을 구현해야 했다.

### 🟩 Action

- 기존처럼 한 줄씩 즉시 write하는 구조를 BufferedWriter 기반 구조로 변경하였다.
- 모든 데이터를 버퍼에 먼저 모은 뒤 한 번에 flush하는 방식으로 디스크 I/O 호출 횟수를 최소화했다.
- 이후 동일한 환경에서 Files.write() 방식과 BufferedWriter 방식을 비교하며 성능 차이를 측정했다.

### 🟨 Result

- BufferedWriter 적용 후 대량 데이터 처리 시 디스크 I/O 병목이 사라졌고, 기존 대비 **약 10배 이상의 저장 속도 향상**을 확인했다.
- 반복적인 OS write 호출은 성능 저하의 원인이 되므로, BufferedWriter·FileOutputStream 등 **버퍼 기반 I/O 사용이 훨씬 효율적**이라는 점을 실무적으로 배울 수 있었다.

---

## 5. 협업 및 피드백

- 팀원들과의 협업 방식:
  - PR이 올라오면 **최우선순위로 코드 리뷰**를 진행했으며, 비즈니스 로직보다는 **최소 구현 사항 충족 여부**에 집중해 검토
  - 소통이 필요한 경우, 단순 채팅이나 DM보다  **직접 보이스로 논의**하여 팀원 간 이해와 방향성을 명확히 맞추고자 했음
  - 다른 담당자의 도메인이 필요할 때는 제가 먼저 **해당 도메인 코드를 작성해 전달**하여, 담당자와 git conflict 발생하지 않도록 사전에 조율
  - 협업 과정에서 의견을 제시할 때는 **반드시 한 가지 이상의 명확한 근거를 함께 제시**해 의사결정의 투명성과 설득력을 높이기 위해 노력함
- 받은 피드백 및 반영한 내용:
  - 회의 중 본인이 맡은 영역에만 집중하고,  **본인 작업이외는 적극적으로 피드백하지 않는다**는 지적을 받음.
  - 회의에서 잘못된 부분이나 개선이 필요한 부분을 발견하더라도,

    *“다른 분들이 알아서 잘 하겠지”*라는 생각으로 **의견 제시를 주저했던 문제**가 있었음.

  - 해당 피드백을 바탕으로, 담당 영역이 아니더라도 팀 전체의 생산성을 위해 **정중하고 명확하게 의견을 제시하는 방식으로 소통 방식을 개선**함.
- 협업 과정에서 느낀 점:
  - 혼자 작업할 때와 달리, 협업 상황에서는 작업 내용을 다른 팀원에게 **명확히 전달하는 과정**, 서로의 PR 승인 대기, 병목 발생 시 **상대 팀원의 작업을 기다리는 시간** 등 다양한 협업 비용이 발생한다는 점을 체감
  - 팀 전체의 **진행 상황을 투명하게 공유하는 것의 중요성**을 깊이 깨달았다. 각자의 흐름을 제대로 파악하지 못하면 작업 병합 과정에서 충돌 및 갈등이 발생함을 경험했다.
  - 메시지나 의견을 전달할 때는 **부드럽고 배려 있는 표현 방식**이 팀 분위기와 소통 효율을 높인다는 것을 배웠다. 팀원 간의 존중은 협업의 기본임을 다시금 느꼈다.
  - 소통이 다소 어색하거나 부담스럽더라도, 적극적으로 대화를 시도할수록 **협업 코스트가 줄어들고 팀 전체의 개발 속도와 완성도가 향상**된다는 것을 깨달았다.

---

## 6. 코드 품질 및 최적화

- 적용한 리팩터링 요소:
  - **Request 데이터 처리 개선**
    - 요청으로 들어오는 문자열(String) 값 중 **Enum으로 대체 가능한 항목을 전부 Enum으로 변경해 유지 보수성 높힘** , Converter를 활용하여 **camelCase 입력값을 snake_case로 변환**하도록 구현.
    - [관련 PR 링크](https://github.com/HR-Bank-Team/sb07-HRBank-team02/pull/69)
  - **백업 서비스 구조 리팩토링**
    - 기존에 **백업 서비스와 Scheduler가 서로의 메서드에 의존**하며 순환 참조가 발생하던 구조를 개선.
    - 공통으로 필요한 메서드 및 변수를 BackupRegister 레이어로 분리하고, 백업 서비스와 Scheduler는 BackupRegister를 참조하도록 변경하여 순환 참조 방지 및 레이어 간 의존성 명확하게 구현함
    - [관련 PR 링크](https://github.com/HR-Bank-Team/sb07-HRBank-team02/pull/65)
- 성능 개선 작업 및 결과:
  - **BufferedWriter 활용**: 기존 `Files.write` 대신 `BufferedWriter`를 사용하여, 대량 데이터 처리 시 발생하는 **디스크 I/O 병목 현상**을 방지함.
  - **성능 향상**: 만 개 이상의 데이터 처리 시, **약 10배 이상의 속도 개선**을 확인함.
  -  [관련 PR 링크](https://github.com/HR-Bank-Team/sb07-HRBank-team02/pull/57)
- 유지보수성 향상을 위해 고려한 점:
  - **기능별 테스트 코드 작성 후 통과 확인**: 각 기능을 개발할 때 테스트 코드를 먼저 작성하고, 테스트를 통과한 경우에만 PR을 올려 **코드 안정성과 신뢰성**을 확보함.
  - **테스트 실패 시 즉시 버그 수정**: 테스트가 통과하지 못하면 해당 커밋을 **기능적 하자가 있는 상태로 판단**하고, 즉시 원인 분석과 수정 작업을 수행함.

---

## 7. 향후 개선 사항

- 추가로 개선하고 싶은 기능:
- 아쉬웠던 점:
  - 코드 구현은 원활히 진행되었으나, **발표 자료 준비 과정에서 역할 분담과 작성이 충분히 이루어지지 않아 발표자의 부담이 증가**함.
  - **CI 자동 테스트를 구현하지 않아**, 검증되지 않은 코드가 develop 브랜치에 병합되는 문제가 발생함.
  - 프로젝트 전반적으로 시간이 부족하여, **코드 유지 보수성보다는 기능 구현에 중점**이 두어졌음.
- 다음 프로젝트에서 적용할 개선점:

1. **발표 준비 및 역할 분담 강화**
  - 발표 자료 작성, 대본 준비 등 **사전 역할 분담을 명확히** 하여, 특정 팀원에게 부담이 집중되지 않도록 함.
  - 일정 관리와 진행 상황 공유를 통해 **팀 전체의 준비 상태를 균형 있게 유지**함.
2. **CI/CD 및 자동 테스트 도입**
  - 커밋 전 **자동 테스트 및 코드 검증**을 수행하도록 CI 환경을 구축하여, 검증되지 않은 코드가 브랜치에 병합되는 문제 방지.
3. **기능 구현과 유지보수성의 균형 확보**
  - 프로젝트 진행 시 **코드 품질과 유지보수성**을 일정 수준 이상 확보하면서 기능 구현을 진행.
  - 테스트 코드 작성, 코드 리뷰 강화 등을 통해 **장기적인 코드 안정성**을 보장.

---

# 8. 코드 리뷰

- [관련 PR 링크](https://github.com/HR-Bank-Team/sb07-HRBank-team02/pull/69)

- **상황**: 프로젝트 환경에서 OSIV(False) 설정으로 인해, 조회 메서드에 트랜잭션 처리가 없으면 에러가 발생할 수 있고, 트랜잭션 처리가 없는 조회 메서드를 코드 리뷰 중 발견하고 피드백함.
- **결과:** 해당 PR 작성한 팀원이 해당 메서드에 `@Transactional(readOnly = true)`를 적용하도록 PR을 수정하여, 영속성 문제 없이 안전하게 동작하도록 개선함.
- 실제로 빌드시 오류를 유발할 수 있는 코드를 코드 리뷰를 통해 확인하고 develop브랜치에 merge 전에 변경하며 develop 브랜치의 무결성을 확보. 코드 리뷰의 순기능을 체감함.
