---
date: 2025-10-13
layout: post
title: Big O Notation
categories: [개발 공부]
tags: [Algorithm]

---

# 시간 복잡도 (Big O Notation)

### 1. 시간 복잡도란 ?

입력한 데이터 n의 크기에 따라 실행되는 조작의 수를 시간 복잡도라고 합니다
예를 들어 n개의 원소를 가진 리스트를 일일이 순환하는 코드가 있다면 
시간 복잡도는 O(n) 이 됩니다.

### 2. 시간 복답도의 표기법의 종류

1. Big O Notation
2. Big Ω Notation
3. Big Θ Notation

시간 복잡도를 표기하는 방식에는 크게 3가지가 있습니다. 최악의 경우를 표기하는 Big O Notation,
최상의 경우를 표기하는 Big Ω Notation, 평균적인 경우를 표기하는 Big Θ Notation입니다.
일반적으로 판단하기 편리하고 평균과 가까운 성능을 보이는 Big O Notation이 사용됩니다.

### 3. Big O Notation의 특징

Big O Notation에서 중요한 건 가장 큰 값의 계수입니다. 예를 들어 O(n^2+n) 이 있다면
이 알고리즘의 시간 복잡도는 O(n^2) 이 됩니다. n을 무한하게 발산 시켰을 때 n^2보다 증가율이 낮은 n은 의미가 
없어집니다. 
  항상 가장 큰 계수를 표기하는 것이 Big O Notation 입니다

### 4. Big O Notation 예시

O(n) 과 O(logn) 을 비교하며 시간복잡도의 중요성을 알아봅시다. 
```java

int [] arr = new int[n];
for(int i = 0; i <n ; i++) {
  if(i == target) break;

  }
```

위에 코드는 모든 요소를 탐사해야하기 때문에 O(n)의 시간 복잡도를 갑니다.

```java
        int left = 0;               // 시작 인덱스
        int right = arr.length - 1; // 끝 인덱스

        while (left <= right) {
            int mid = (left + right) / 2; // 중간 인덱스 계산

            if (arr[mid] == target) {
                return mid; // 값을 찾으면 인덱스 반환
            } else if (arr[mid] < target) {
                left = mid + 1; // 중간 값보다 크면 오른쪽 탐색
            } else {
                right = mid - 1; // 중간 값보다 작으면 왼쪽 탐색
            }
        }
```

가장 유명한 O(logn) 의 예시인 이진 탐색 (Binary Search) 알고리즘 입니다. 현재 탐색 중인
값에 따라 나머지 절반을 탐색 범위에서 배제하며 필요한 연산의 수를 낮추는 알고리즘입니다.

만약 주어진 배열의 크기가 10^6이라면 O(n) 의 연산 수는 10^6 이 됩니다.
O(log2 (n)) 의 연산 수는  6 * log2 (10)  약 20 이 됩니다. 시간 복잡도 차이로
동일한 원소 탐색이지만 엄청난 연산 수의 차이가 납니다.

### 5 . 마치며

현재는 하드웨어 성능 향상으로 시간 복잡도를 엄격히 지키는 것은 비효율적입니다. 그래도
각종 코딩 테스트 및 연산 속도 향상을 위한 최적화 과정등 여전히 시간 복잡도가 필요한 분야가 많습니다.
시간 복잡도는 프로그래머가 평상시에 알고 신경 써야하는 중요한 항목입니다.

